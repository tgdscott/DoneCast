"""
AI Theme Generator Service

Analyzes podcasts and generates custom themed designs that can be applied
to the block-based website builder.
"""

import json
import logging
from datetime import datetime
from typing import Any, Dict, List, Optional
from pydantic import BaseModel, Field

from api.models.podcast import Podcast
from api.services.ai_content import client_router as ai_client
from api.services.podcast_websites import (
  _get_readable_text_color,
  _get_contrast_ratio,
  _hex_to_rgb_tuple,
  _ensure_readable_text_color,
)

log = logging.getLogger(__name__)


class ThemeSpec(BaseModel):
    """Theme specification generated by AI analysis."""
    mood: str = Field(..., description="Overall vibe (e.g., 'playful-cinematic', 'professional', 'cozy')")
    color_palette: Dict[str, str] = Field(..., description="CSS color variables")
    typography: Dict[str, str] = Field(..., description="Font choices and styles")
    visual_motifs: List[str] = Field(default_factory=list, description="Design elements to incorporate")
    animations: List[str] = Field(default_factory=list, description="Animation types to include")
    component_styles: Dict[str, str] = Field(default_factory=dict, description="Section-specific style variants")
    effects: List[str] = Field(default_factory=list, description="Visual effects to apply")


class ThemeAnalysisResult(BaseModel):
    """Complete theme analysis result."""
    theme_spec: ThemeSpec
    sections_config: Dict[str, Any]
    css: str
    description: str = Field(..., description="Human-readable description of the generated theme")


def analyze_podcast_for_theme(
    podcast: Podcast,
    cover_url: Optional[str] = None,
    tagline: Optional[str] = None,
    design_prefs: Optional[Dict[str, Any]] = None
) -> ThemeSpec:
    """
    Analyze podcast metadata and cover art to generate a theme specification.
    
    Uses AI vision to analyze the cover image and identify visual motifs, colors, and tone.
    
    Args:
        podcast: The podcast to analyze
        cover_url: URL to podcast cover art (optional)
        tagline: Podcast tagline if available
        design_prefs: User-provided design preferences (vibe, colors, notes)
        
    Returns:
        ThemeSpec with colors, typography, motifs, animations, etc.
    """
    import requests
    import base64
    
    # Build analysis prompt - enhanced to match ChatGPT-style analysis
    description = podcast.description or "A podcast"
    
    # Try to fetch and encode the cover image for vision analysis
    image_data = None
    image_mime = None
    if cover_url:
        # Ensure cover_url is a full URL (not a relative path)
        resolved_url = cover_url
        if not cover_url.startswith(('http://', 'https://')):
            # Try to resolve relative path via storage abstraction
            try:
                from infrastructure.storage import get_public_audio_url
                resolved = get_public_audio_url(cover_url, expiration_days=1)
                if resolved:
                    resolved_url = resolved
                else:
                    log.warning("Could not resolve relative cover path to URL: %s", cover_url)
                    resolved_url = None
            except Exception as resolve_exc:
                log.warning("Failed to resolve cover URL: %s", resolve_exc)
                resolved_url = None
        
        if resolved_url:
            try:
                response = requests.get(resolved_url, timeout=10)
                if response.status_code == 200:
                    image_data = base64.b64encode(response.content).decode('utf-8')
                    # Detect MIME type
                    if resolved_url.lower().endswith('.png'):
                        image_mime = 'image/png'
                    elif resolved_url.lower().endswith('.jpg') or resolved_url.lower().endswith('.jpeg'):
                        image_mime = 'image/jpeg'
                    elif resolved_url.lower().endswith('.webp'):
                        image_mime = 'image/webp'
                    else:
                        # Try to detect from content
                        if response.content.startswith(b'\x89PNG'):
                            image_mime = 'image/png'
                        elif response.content.startswith(b'\xff\xd8'):
                            image_mime = 'image/jpeg'
                        else:
                            image_mime = 'image/jpeg'  # Default fallback
                    log.info("Successfully loaded cover image for vision analysis (%d bytes)", len(response.content))
            except Exception as e:
                log.warning("Failed to fetch cover image for vision analysis (URL: %s): %s", resolved_url[:100] if resolved_url else 'None', e)
    
    # Enhanced prompt that asks for deep visual analysis
    prompt = f"""You are a web design expert analyzing a podcast cover image and metadata to generate a comprehensive design theme.

Podcast Title: {podcast.name}
Description: {description}
Tagline: {tagline or 'Not provided'}

{"I'm providing the podcast cover image - analyze it carefully." if image_data else "Cover art is not available - base your analysis on the title and description."}

**Your Task:**
1. Analyze the visual elements in the cover image (if provided):
   - Identify specific objects, symbols, and visual motifs (e.g., marquee lights, popcorn, chainsaws, theater seats, dinosaurs, retro signs, etc.)
   - Extract dominant colors and their emotional associations
   - Determine the overall tone and vibe (e.g., "retro movie theater", "cinematic horror-comedy", "playful-slasher", "cozy storytelling", etc.)
   - Note any stylistic elements (vintage, modern, minimalist, maximalist, etc.)

2. Based on the podcast title, description, and visual analysis, generate a complete design theme that:
   - Matches the visual style and tone of the cover art
   - Uses colors extracted from or inspired by the image
   - Incorporates visual motifs as CSS elements (e.g., marquee light animations, ticket-style buttons, movie poster cards, etc.)
   - Creates a cohesive, memorable design that feels like stepping into the podcast's world

**Visual Motifs to Consider:**
- If you see marquee lights/theater signs â†’ include "marquee-lights", "theater-bulbs"
- If you see movie/cinema elements â†’ include "movie-poster-style", "cinematic"
- If you see retro/vintage elements â†’ include "retro", "vintage-theater"
- If you see playful/horror elements â†’ include "playful-horror", "slasher-comedy"
- If you see specific objects (popcorn, chainsaws, etc.) â†’ include those as motifs

**Component Style Variants:**
- "marquee-style" for hero sections with animated marquee borders
- "ticket-style" for buttons that look like cinema tickets with perforated edges
- "movie-poster-style" for episode cards styled like movie posters
- "retro-cassette" or "reel-style" for audio players
"""

    # IMPORTANT: Add user preferences if they exist
    if design_prefs:
        prompt += f"""
\n**USER DESIGN INSTRUCTIONS (PRIORITY)**
The user has provided specific instructions for the website design. You MUST prioritize these over your analysis of the cover art if they conflict.

"""
        if design_prefs.get('design_vibe'):
            prompt += f"- **Desired Vibe:** {design_prefs['design_vibe']}\n"
        if design_prefs.get('color_preference'):
            prompt += f"- **Color Preferences:** {design_prefs['color_preference']} (Use these exact colors if possible)\n"
        if design_prefs.get('additional_notes'):
            prompt += f"- **Additional Notes:** {design_prefs['additional_notes']}\n"
        
        prompt += "\n**CRITICAL:** If the user asks for specific colors or styles (e.g. 'high contrast', 'neon', 'black and white'), you MUST generate a theme that respects these wishes.\n"

    prompt += f"""
Output a JSON object with this exact structure:
{{
  "mood": "descriptive-mood-string (e.g., 'retro-movie-theater', 'cinematic-horror-comedy', 'playful-slasher-cinema')",
  "color_palette": {{
    "bg": "#hexcolor (deep background color, e.g., dark navy for theaters)",
    "bg_elev": "#hexcolor (elevated surface color, slightly lighter than bg)",
    "text": "#hexcolor (main text color, ensure good contrast)",
    "muted": "#hexcolor (muted/secondary text)",
    "primary": "#hexcolor (dominant brand color from image, e.g., gold for marquee lights)",
    "primary_700": "#hexcolor (darker shade of primary for gradients)",
    "accent": "#hexcolor (accent color, e.g., neon cyan for hovers)",
    "danger": "#hexcolor (accent color, e.g., deep red for theater seats)"
  }},
  "typography": {{
    "heading_font": "Font Name, fallback, sans-serif (e.g., 'Anton, Impact, system-ui' for marquee-style)",
    "body_font": "Font Name, fallback, sans-serif (e.g., 'Inter, system-ui' for readability)",
    "heading_style": "uppercase/bold/normal, letter-spacing value (e.g., 'uppercase, 0.5px' for marquee)"
  }},
  "visual_motifs": ["specific-motif-1", "specific-motif-2", "specific-motif-3"],
  "animations": ["animation-type-1", "animation-type-2"],
  "component_styles": {{
    "hero": "marquee-style or standard",
    "buttons": "ticket-style or standard",
    "episode_cards": "movie-poster-style or standard",
    "audio_player": "retro-cassette or standard"
  }},
  "effects": ["effect-1", "effect-2"]
}}

**Important:**
- Extract colors directly from the image if possible
- Identify specific visual motifs (don't be generic - be specific like "marquee-lights", "popcorn-kernels", "chainsaws", "theater-seats")
- Match the tone exactly (if it's playful horror, reflect that in the mood)
- Ensure text colors have sufficient contrast for accessibility

Output ONLY valid JSON, no explanations or markdown fences."""

    try:
        # If we have image data, use vision-capable model with multimodal input
        if image_data and image_mime:
            # Use Gemini's vision API by passing image as part of content
            # The generate function needs to support this, so we'll use a workaround:
            # Pass image URL in prompt and let AI analyze it, OR use direct API call
            # For now, enhance prompt with image analysis instructions
            # Include image URL in prompt for AI to reference
            # Note: For true vision analysis, we'd need to pass the image directly to Gemini's vision API
            # For now, we'll enhance the prompt to ask for detailed analysis based on the image URL
            vision_prompt = f"""{prompt}

**CRITICAL: Analyze the podcast cover image at this URL: {cover_url}**

Look at the image carefully and identify:
- Every visual element, object, symbol, and color you see
- Specific motifs (e.g., marquee lights, popcorn, chainsaws, theater seats, dinosaurs, retro signs, etc.)
- The exact color palette (extract dominant colors and their hex codes)
- The precise tone and style (e.g., "retro movie theater", "cinematic horror-comedy", "playful-slasher")
- Visual style elements (vintage, modern, minimalist, maximalist, etc.)

Be extremely specific about visual motifs - don't be generic:
- If you see marquee lights â†’ include "marquee-lights" and "theater-bulbs"
- If you see dinosaurs â†’ include "dinosaurs" 
- If you see chainsaws â†’ include "chainsaws"
- If you see popcorn â†’ include "popcorn-kernels"
- If you see theater seats â†’ include "theater-seats"
- Match the exact vibe and colors from what you see in the image

Generate CSS that visually matches what you see - if it's a retro theater vibe, include marquee animations. If it's cinematic, use movie poster styling. Make it feel like stepping into the podcast's world."""
            
            # Try to use vision model if available
            try:
                # Check if we can use a vision-capable model
                response = ai_client.generate(vision_prompt, max_output_tokens=4096, temperature=0.7)
            except Exception as vision_err:
                log.warning("Vision analysis failed, falling back to text-only: %s", vision_err)
                response = ai_client.generate(prompt, max_output_tokens=4096, temperature=0.7)
        else:
            # No image, use enhanced text-only prompt
            response = ai_client.generate(prompt, max_output_tokens=4096, temperature=0.7)
        
        # Clean up response
        response = response.strip()
        if response.startswith("```json"):
            response = response[7:]
        elif response.startswith("```"):
            response = response[3:]
        if response.endswith("```"):
            response = response[:-3]
        response = response.strip()
        
        # Parse JSON
        theme_data = json.loads(response)
        
        # Validate and create ThemeSpec
        return ThemeSpec(**theme_data)
        
    except json.JSONDecodeError as e:
        log.error("Failed to parse theme JSON from AI: %s", e)
        if 'response' in locals() and isinstance(response, str):
            response_preview = response[:1000] if len(response) > 1000 else response
            log.debug("AI response was: %s", response_preview)
        # Return a default theme as fallback
        return _get_default_theme_spec(podcast.name)
    except Exception as e:
        log.exception("Failed to generate theme spec: %s", e)
        return _get_default_theme_spec(podcast.name)


def _get_default_theme_spec(podcast_name: str) -> ThemeSpec:
    """Return a default theme spec as fallback."""
    return ThemeSpec(
        mood="professional-modern",
        color_palette={
            "bg": "#0f172a",
            "bg_elev": "#1e293b",
            "text": "#f8fafc",
            "muted": "#94a3b8",
            "primary": "#3b82f6",
            "primary_700": "#2563eb",
            "accent": "#8b5cf6",
            "danger": "#ef4444"
        },
        typography={
            "heading_font": "Inter, system-ui, sans-serif",
            "body_font": "Inter, system-ui, sans-serif",
            "heading_style": "bold, normal"
        },
        visual_motifs=["modern-minimal"],
        animations=["smooth-transitions"],
        component_styles={
            "hero": "standard",
            "buttons": "standard",
            "episode_cards": "standard",
            "audio_player": "standard"
        },
        effects=["subtle-shadows"]
    )


    def _enforce_palette_contrast(theme_spec: ThemeSpec) -> ThemeSpec:
      """Normalize AI palette choices so text always clears WCAG contrast thresholds."""

      colors = dict(theme_spec.color_palette or {})
      bg = colors.get("bg") or "#0f172a"
      bg_elev = colors.get("bg_elev") or colors.get("bg") or "#1e293b"

      # Ensure main text is readable against the base background
      desired_text = colors.get("text") or "#f8fafc"
      safe_text = _get_readable_text_color(bg, min_contrast=4.5)
      if desired_text.lower() != safe_text.lower():
        log.warning(
          "Theme text color %s failed contrast on bg %s. Auto-adjusting to %s.",
          desired_text,
          bg,
          safe_text,
        )
        colors["text"] = safe_text

      # Muted/secondary text still needs to be readable, but 3.0:1 is acceptable
      muted_color = colors.get("muted")
      if muted_color:
        safe_muted = _ensure_readable_text_color(muted_color, bg, min_contrast=3.0)
        colors["muted"] = safe_muted

      # Elevated surface text should also be readable if bg_elev differs
      safe_elev_text = _get_readable_text_color(bg_elev, min_contrast=4.5)
      colors.setdefault("bg_elev_text", safe_elev_text)

      theme_spec.color_palette = colors
      return theme_spec


def map_theme_to_sections(theme_spec: ThemeSpec, podcast: Podcast) -> Dict[str, Any]:
    """
    Map theme specification to section configurations.
    
    Returns:
        {
            "sections_order": [...],
            "sections_config": {...},
            "section_styles": {...}
        }
    """
    # Determine section order based on theme
    sections_order = ["hero", "latest-episodes", "subscribe", "footer"]
    
    # Map component styles to section variants
    # Use CSS variables instead of hardcoded colors so theme CSS can control them
    sections_config = {
        "hero": {
            "variant": theme_spec.component_styles.get("hero", "standard"),
            "title": podcast.name,
            "subtitle": podcast.description or f"Welcome to {podcast.name}",
            "show_cover_art": True,  # Always show cover art in hero
            "background_style": "gradient" if "gradient" in theme_spec.effects else "solid",
            # Use CSS variables - theme CSS will provide the actual colors
            # These will be overridden by CSS !important rules
            "background_color": "var(--bg)",
            "text_color": "var(--text)"
        },
        "latest-episodes": {
            "variant": theme_spec.component_styles.get("episode_cards", "standard"),
            "count": 6,
            "layout": "grid",
            "show_descriptions": True,
            "show_dates": True
        },
        "subscribe": {
            "heading": "Subscribe & Listen",
            "layout": "icons"
        },
        "footer": {
            "show_social_links": True,
            "show_subscribe_links": True
        }
    }
    
    # Generate section-specific CSS classes
    section_styles = {}
    if theme_spec.component_styles.get("hero") != "standard":
        section_styles["hero"] = f".hero.{theme_spec.component_styles['hero']}"
    if theme_spec.component_styles.get("episode_cards") != "standard":
        section_styles["episodes"] = f".episode-card.{theme_spec.component_styles['episode_cards']}"
    
    return {
        "sections_order": sections_order,
        "sections_config": sections_config,
        "section_styles": section_styles
    }


def generate_theme_css(theme_spec: ThemeSpec, section_configs: Dict[str, Any]) -> str:
    """
    Generate complete CSS that styles building blocks to match the theme.
    
    This CSS will:
    1. Define CSS variables from color palette
    2. Add typography rules
    3. Style section variants
    4. Include animations
    5. Add component-specific styles
    """
    colors = theme_spec.color_palette
    typo = theme_spec.typography
    
    # Build CSS
    css_parts = []
    
    # CSS Variables - use f-string to avoid format() issues with CSS curly braces
    bg = colors.get("bg", "#0f172a")
    bg_elev = colors.get("bg_elev", "#1e293b")
    text = colors.get("text", "#f8fafc")
    muted = colors.get("muted", "#94a3b8")
    primary = colors.get("primary", "#3b82f6")
    primary_700 = colors.get("primary_700", "#2563eb")
    accent = colors.get("accent", "#8b5cf6")
    danger = colors.get("danger", "#ef4444")
    heading_font = typo.get("heading_font", "Inter, sans-serif")
    body_font = typo.get("body_font", "Inter, sans-serif")
    
    # CRITICAL: Ensure text colors meet WCAG AA contrast requirements
    # Validate and fix text color against background
    text_rgb = _hex_to_rgb_tuple(text)
    bg_rgb = _hex_to_rgb_tuple(bg)
    text_contrast = _get_contrast_ratio(text_rgb, bg_rgb)
    if text_contrast < 4.5:
        log.warning(
            "Theme text color contrast %.2f:1 below WCAG AA minimum (4.5:1) for bg %s. "
            "Auto-correcting to readable color.",
            text_contrast, bg
        )
        text = _get_readable_text_color(bg, min_contrast=4.5)
    
    # Check primary color contrast against background (used for headings)
    primary_rgb = _hex_to_rgb_tuple(primary)
    primary_contrast = _get_contrast_ratio(primary_rgb, bg_rgb)
    
    # If primary contrast is poor, we must NOT use it for text/headings on this background
    # We'll create a "primary_text" variable that is safe to use
    primary_text = primary
    if primary_contrast < 3.0:  # Absolute minimum for large text
        log.warning(
            "Theme primary color contrast %.2f:1 too low for bg %s. "
            "Using text color for headings instead of primary.",
            primary_contrast, bg
        )
        primary_text = text  # Fallback to main text color which is already safe
    elif primary_contrast < 4.5:
        # It's okay for large text (headings), but maybe marginal for small text
        # We'll try to tweak it slightly if possible, or just accept it for headings
        pass

    # Validate muted text color
    muted_rgb = _hex_to_rgb_tuple(muted)
    muted_contrast = _get_contrast_ratio(muted_rgb, bg_rgb)
    if muted_contrast < 4.5:
        # Muted text can be slightly lower contrast, but still needs to be readable
        if muted_contrast < 3.0:  # Even fails large text requirement
            log.warning(
                "Theme muted color contrast %.2f:1 too low for bg %s. Auto-correcting.",
                muted_contrast, bg
            )
            # Use a lighter/darker version based on background
            if _get_contrast_ratio((255, 255, 255), bg_rgb) > _get_contrast_ratio((30, 41, 59), bg_rgb):
                muted = "#cbd5e1"  # Light gray
            else:
                muted = "#64748b"  # Medium gray
    
        # Persist corrected palette values so future steps have the safe versions
        colors["text"] = text
        colors["muted"] = muted
        colors["primary_text"] = primary_text

    # Log the colors being used for debugging
    log.info("Generating CSS with colors: primary=%s, bg=%s, text=%s (contrast: %.2f:1)", 
             primary, bg, text, _get_contrast_ratio(_hex_to_rgb_tuple(text), bg_rgb))
    
    css_parts.append(f"""/* AI-Generated Theme CSS */
:root {{
  /* Color Palette */
  --bg: {bg};
  --bg-elev: {bg_elev};
  --text: {text};
  --muted: {muted};
  --primary: {primary};
  --primary-text: {primary_text};
  --primary-700: {primary_700};
  --accent: {accent};
  --danger: {danger};
  
  /* Typography */
  --font-heading: {heading_font};
  --font-body: {body_font};
  
  /* Spacing */
  --radius: 14px;
  --shadow: 0 10px 30px rgba(0,0,0,.35);
  
  /* Legacy color variable names for compatibility */
  --color-primary: {primary};
  --color-secondary: {muted};
  --color-accent: {accent};
  --color-background-light: {bg};
  --color-background-dark: {bg_elev};
  --color-text-light: {text};
  --color-text-dark: {bg};
}}
""")
    
    # Base Styles - Apply theme to entire page
    css_parts.append(f"""
* {{ box-sizing: border-box; }}
html, body {{ height: 100%; }}
body {{
  margin: 0;
  background: var(--bg, {bg}) !important;
  color: var(--text, {text}) !important;
  font-family: var(--font-body, {body_font});
  line-height: 1.6;
}}

/* Force any inherited Tailwind text utility to respect readable colors */
body,
main,
section,
p,
li,
span,
.prose p,
.prose li,
[data-section-id] p,
[data-section-id] li,
[data-section-id] span,
[data-section-id] strong,
[data-section-id] em,
[data-section-id] [class*="text-slate"],
[data-section-id] [class*="text-gray"],
[data-section-id] [class*="text-zinc"],
[data-section-id] [class*="text-neutral"],
[data-section-id] [class*="text-stone"],
[data-section-id] [class*="text-white"] {{
  color: var(--text, {text}) !important;
}}

/* Apply theme colors to hero sections - use high specificity to override inline styles */
.hero,
div.hero,
.w-full.hero,
div.w-full.hero {{
  background: var(--bg, {bg}) !important;
  color: var(--text, {text}) !important;
}}

/* Force override inline background colors */
div[class*="hero"][style] {{
  background: var(--bg, {bg}) !important;
  color: var(--text, {text}) !important;
}}

/* Override Tailwind text color classes in hero sections - HIGHEST PRIORITY */
.hero [class*="text-slate"],
.hero [class*="text-gray"],
.hero [class*="text-white"],
.hero [class*="text-blue"],
.hero h1, .hero h2, .hero h3,
.hero .text-4xl, .hero .text-5xl, .hero .text-3xl,
.hero h1[style], .hero h2[style], .hero h3[style],
div.hero h1, div.hero h2, div.hero h3,
div[class*="hero"] h1, div[class*="hero"] h2, div[class*="hero"] h3 {{
  color: var(--primary-text, {primary_text}) !important;
}}

/* Force primary color on hero h1 even with inline styles - MAXIMUM SPECIFICITY */
.hero h1[style*="color"],
.hero .hero-title,
.hero h1.hero-title,
div.hero h1.hero-title,
div[class*="hero"] h1.hero-title,
.w-full.hero h1.hero-title {{
  color: var(--primary-text, {primary_text}) !important;
}}

/* Ensure hero title uses primary color - override any other rules including inline styles */
h1.hero-title,
.hero h1.hero-title,
div.hero h1.hero-title,
div[class*="hero"] h1.hero-title,
.w-full.hero h1.hero-title,
div.w-full.hero h1.hero-title {{
  color: var(--primary-text, {primary_text}) !important;
}}

/* Nuclear option: target by class combination with maximum specificity */
.text-4xl.hero-title,
.text-5xl.hero-title,
.font-bold.hero-title,
.leading-tight.hero-title,
.hero .text-4xl.hero-title,
.hero .text-5xl.hero-title,
div.hero .text-4xl.hero-title,
div.hero .text-5xl.hero-title,
.w-full.hero .text-4xl.hero-title,
.w-full.hero .text-5xl.hero-title {{
  color: var(--primary-text, {primary_text}) !important;
}}

/* Target ALL h1 elements inside .hero regardless of other classes - ABSOLUTE MAXIMUM SPECIFICITY */
.hero h1,
div.hero h1,
.w-full.hero h1,
div.w-full.hero h1,
div[class*="hero"] h1,
div.w-full.relative.overflow-hidden.hero h1,
div[class*="w-full"][class*="hero"] h1,
div.w-full.relative.overflow-hidden.hero.marquee-style h1 {{
  color: var(--primary-text, {primary_text}) !important;
  /* Force override any inline styles - inline styles have higher specificity than classes, so we need !important */
  color: var(--primary-text, {primary_text}) !important;
}}

/* Override inline styles specifically - inline styles have very high specificity */
.hero h1[style*="color"],
div.hero h1[style*="color"],
.w-full.hero h1[style*="color"],
div.w-full.relative.overflow-hidden.hero h1[style*="color"],
div.w-full.relative.overflow-hidden.hero.marquee-style h1[style*="color"] {{
  color: var(--primary-text, {primary_text}) !important;
}}

/* DIRECT FALLBACK - if CSS variable doesn't work, use the actual color */
.hero h1,
div.hero h1,
.w-full.hero h1,
div.w-full.relative.overflow-hidden.hero h1 {{
  color: {primary_text} !important;
  /* Also set via CSS variable for dynamic theming */
  color: var(--primary-text, {primary_text}) !important;
}}

/* Even more specific - target the exact structure */
div.w-full.relative.overflow-hidden.hero > div > div > h1,
div.w-full.relative.overflow-hidden.hero h1.hero-title,
div.w-full.relative.overflow-hidden.hero h1.text-4xl,
div.w-full.relative.overflow-hidden.hero h1.text-5xl {{
  color: var(--primary-text, {primary_text}) !important;
}}

/* Apply theme to episode cards */
.episode-card {{
  background: var(--bg-elev, {bg_elev}) !important;
  border-color: rgba(255, 255, 255, 0.1) !important;
  color: var(--text, {text}) !important;
}}

/* Override Tailwind text colors for headings - BUT only on dark backgrounds */
/* On white/light backgrounds, use dark text for readability */
.bg-white h1, .bg-white h2, .bg-white h3,
.bg-white p, .bg-white li, .bg-white span,
.bg-white [class*="text-"],
[class*="bg-white"] h1, [class*="bg-white"] h2, [class*="bg-white"] h3,
[class*="bg-white"] p, [class*="bg-white"] li, [class*="bg-white"] span,
[class*="bg-white"] [class*="text-slate"], [class*="bg-white"] [class*="text-gray"],
[class*="bg-white"] [class*="text-stone"], [class*="bg-white"] [class*="text-neutral"],
.bg-gray-50 h1, .bg-gray-50 p, .bg-slate-50 h1, .bg-slate-50 p,
[class*="bg-gray-50"] *, [class*="bg-slate-50"] * {{
  color: #1e293b !important; /* Dark slate for readability on white */
}}

/* Apply primary color to headings ONLY on dark backgrounds (hero, dark sections) */
.hero h1, .hero h2, .hero h3,
[style*="background"][style*="var(--bg)"] h1,
[style*="background"][style*="var(--bg)"] h2,
[style*="background"][style*="var(--bg)"] h3,
div[class*="hero"] h1, div[class*="hero"] h2, div[class*="hero"] h3 {{
  color: var(--primary-text, {primary_text}) !important;
}}

.container {{ max-width: 1100px; margin: 0 auto; padding: 24px; }}

/* Target sections using data-section-id attributes (most reliable) */
[data-section-id="hero"] .hero,
[data-section-id="hero"] .w-full.hero,
[data-section-id="hero"] div.hero {{
  background: var(--bg, {bg}) !important;
  color: var(--text, {text}) !important;
}}

[data-section-id="hero"] h1,
[data-section-id="hero"] .hero-title,
[data-section-id="hero"] h1.hero-title {{
  color: var(--primary-text, {primary_text}) !important;
  font-family: var(--font-heading, {heading_font}) !important;
}}

[data-section-id="header"] .w-full,
[data-section-id="header"] div.w-full {{
  background-color: var(--bg-elev, {bg_elev}) !important;
  color: var(--text, {text}) !important;
}}

[data-section-id="latest-episodes"] .w-full,
[data-section-id="latest-episodes"] .bg-white,
[data-section-id="latest-episodes"] div.bg-white {{
  background-color: var(--bg, {bg}) !important;
}}

[data-section-id="latest-episodes"] h2,
[data-section-id="latest-episodes"] h3 {{
  color: var(--primary-text, {primary_text}) !important;
  font-family: var(--font-heading, {heading_font}) !important;
}}

/* Override Tailwind classes with theme colors - HIGH SPECIFICITY */
.w-full.bg-white {{
  background-color: var(--bg, {bg}) !important;
}}

/* Buttons and links */
a {{
  color: var(--accent, {accent}) !important;
}}

a:hover {{
  color: var(--primary, {primary}) !important;
}}

/* Episode cards */
[data-section-id="latest-episodes"] .rounded-lg,
[data-section-id="latest-episodes"] .border {{
  background-color: var(--bg-elev, {bg_elev}) !important;
  border-color: var(--muted, {muted}) !important;
  color: var(--text, {text}) !important;
}}
""")
    
    # Hero Section Variants
    hero_variant = section_configs.get("sections_config", {}).get("hero", {}).get("variant", "standard")
    
    # Always add base hero styling
    css_parts.append(f"""
/* Base Hero Styling */
.hero {{
  background: var(--bg, {bg}) !important;
  color: var(--text, {text}) !important;
  position: relative;
}}
""")
    
    if hero_variant == "marquee-style":
        css_parts.append("""
/* Marquee Hero Style */
.hero.marquee-style {
  position: relative;
  padding: 24px;
  border-radius: var(--radius);
  background: linear-gradient(180deg, var(--bg-elev) 0%, var(--bg) 100%);
  box-shadow: var(--shadow);
  overflow: hidden;
}

.hero.marquee-style::before,
.hero.marquee-style::after {
  content: "";
  position: absolute;
  inset: -6px;
  border-radius: calc(var(--radius) + 8px);
  padding: 6px;
  background: conic-gradient(from 0deg, var(--primary) 0 4deg, transparent 4deg 8deg) border-box;
  -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  animation: bulbs 6s linear infinite;
  opacity: 0.75;
}

.hero.marquee-style::after {
  filter: blur(8px);
  opacity: 0.35;
}

@keyframes bulbs {
  to { transform: rotate(360deg); }
}
""")
    
    # Episode Card Variants
    episode_variant = section_configs.get("sections_config", {}).get("latest-episodes", {}).get("variant", "standard")
    if episode_variant == "movie-poster-style":
        css_parts.append("""
/* Movie Poster Episode Cards */
.episode-card.movie-poster-style {
  background: linear-gradient(180deg, var(--bg-elev) 0%, var(--bg) 100%);
  border: 1px solid rgba(255,255,255,.06);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  overflow: hidden;
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}

.episode-card.movie-poster-style:hover {
  transform: translateY(-2px);
  box-shadow: 0 18px 40px rgba(0,0,0,.45);
}

.episode-card.movie-poster-style .poster {
  height: 170px;
  background: linear-gradient(180deg, rgba(183,28,28,.25), rgba(183,28,28,0));
  border-bottom: 1px solid rgba(255,255,255,.06);
}
""")
    
    # Button Variants
    button_variant = theme_spec.component_styles.get("buttons", "standard")
    if button_variant == "ticket-style":
        css_parts.append("""
/* Ticket-Style Buttons */
.btn.ticket-style {
  position: relative;
  display: inline-flex;
  align-items: center;
  gap: 10px;
  padding: 14px 18px;
  font-weight: 700;
  letter-spacing: 0.4px;
  text-transform: uppercase;
  background: linear-gradient(180deg, var(--primary) 0%, var(--primary-700) 100%);
  color: #1a1200;
  border: none;
  cursor: pointer;
  border-radius: 12px;
  box-shadow: 0 6px 0 rgba(0,0,0,.25), var(--shadow);
  transition: transform 0.12s ease, filter 0.12s ease;
  clip-path: polygon(8px 0, calc(100% - 8px) 0, 100% 8px, 100% calc(100% - 8px), calc(100% - 8px) 100%, 8px 100%, 0 calc(100% - 8px), 0 8px);
}

.btn.ticket-style::before,
.btn.ticket-style::after {
  content: "";
  position: absolute;
  top: 0;
  bottom: 0;
  width: 10px;
  background: radial-gradient(circle at 50% 6px, rgba(0,0,0,.45) 2px, transparent 2px) repeat-y;
  background-size: 10px 14px;
  opacity: 0.6;
}

.btn.ticket-style::before { left: -6px; }
.btn.ticket-style::after { right: -6px; transform: scaleX(-1); }

.btn.ticket-style:hover {
  transform: translateY(-1px);
  filter: saturate(1.1);
}

.btn.ticket-style:active {
  transform: translateY(1px);
}
""")
    
    # Typography - Override Tailwind classes with high specificity
    # CRITICAL: Only apply primary color on dark backgrounds, use dark text on white backgrounds
    heading_style = typo.get("heading_style", "bold, normal")
    if "uppercase" in heading_style:
        css_parts.append(f"""
/* Typography - Override Tailwind text color classes */
/* On dark backgrounds (hero, dark sections) - use primary color with glow */
.hero h1, .hero h2, .hero h3,
.hero .text-4xl, .hero .text-5xl, .hero .text-3xl,
.hero [class*="text-"],
div[class*="hero"] h1, div[class*="hero"] h2, div[class*="hero"] h3 {{
  font-family: var(--font-heading, {heading_font}) !important;
  text-transform: uppercase !important;
  letter-spacing: 0.5px !important;
  color: var(--primary, {primary}) !important;
  text-shadow: 0 2px 0 rgba(0,0,0,.5), 0 0 24px rgba(255,193,7,.35) !important;
}}

/* On white/light backgrounds - use dark text for readability (NO glow) */
.bg-white h1, .bg-white h2, .bg-white h3,
.bg-white .text-4xl, .bg-white .text-5xl, .bg-white .text-3xl,
[class*="bg-white"] h1, [class*="bg-white"] h2, [class*="bg-white"] h3,
[class*="bg-white"] [class*="text-"] {{
  font-family: var(--font-heading, {heading_font}) !important;
  text-transform: uppercase !important;
  letter-spacing: 0.5px !important;
  color: #1e293b !important; /* Dark slate for contrast on white */
  text-shadow: none !important; /* No glow on white backgrounds */
}}
""")
    else:
        # Even without uppercase, still apply primary color to headings on dark backgrounds only
        css_parts.append(f"""
/* Typography - Apply primary color to headings on dark backgrounds */
.hero h1, .hero h2, .hero h3,
.hero [class*="text-"],
div[class*="hero"] h1, div[class*="hero"] h2, div[class*="hero"] h3 {{
  color: var(--primary, {primary}) !important;
  font-family: var(--font-heading, {heading_font}) !important;
}}

/* On white backgrounds - use dark text */
.bg-white h1, .bg-white h2, .bg-white h3,
[class*="bg-white"] h1, [class*="bg-white"] h2, [class*="bg-white"] h3,
[class*="bg-white"] [class*="text-slate"], [class*="bg-white"] [class*="text-gray"] {{
  color: #1e293b !important; /* Dark text for readability */
  font-family: var(--font-heading, {heading_font}) !important;
}}
""")
    
    # Visual Motifs - actually implement them!
    motifs_str = ' '.join(theme_spec.visual_motifs).lower()
    
    # Popcorn kernels motif
    if "popcorn" in motifs_str or ("cinema" in motifs_str and "theater" in motifs_str):
        css_parts.append("""
/* Popcorn Decorative Elements */
.popcorn-decoration::before {
  content: "ðŸ¿";
  font-size: 1.2em;
  margin-right: 0.5em;
  opacity: 0.8;
}

.episode-card::after {
  content: "";
  position: absolute;
  top: -10px;
  right: 10px;
  width: 20px;
  height: 20px;
  background: radial-gradient(circle, var(--primary) 0%, transparent 70%);
  border-radius: 50%;
  opacity: 0.3;
  pointer-events: none;
}
""")
    
    # Theater bulbs / Marquee lights
    if "marquee" in motifs_str or "lights" in motifs_str or "theater" in motifs_str or "bulb" in motifs_str:
        css_parts.append(f"""
/* Theater Bulbs / Marquee Lights */
.bulb-row {{
  display: flex !important;
  justify-content: center;
  gap: 8px;
  padding: 12px 0 26px;
  opacity: 0.85;
  z-index: 10;
  pointer-events: none;
}}

.bulb {{
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: radial-gradient(circle at 40% 40%, #fff, var(--primary, {primary}) 55%, var(--primary-700, {primary_700}) 70%, #b66a00 100%) !important;
  box-shadow: 0 0 12px rgba(255,193,7,.9) !important;
  animation: twinkle 2s ease-in-out infinite;
}}

.bulb:nth-child(odd) {{ animation-delay: 0.8s; }}
.bulb:nth-child(even) {{ animation-delay: 0.4s; }}

@keyframes twinkle {{
  0%, 100% {{ filter: brightness(1); opacity: 0.85; }}
  50% {{ filter: brightness(1.6); opacity: 1; }}
}}

/* Carousel dots / pagination indicators - make them yellow */
[class*="carousel"] [class*="dot"],
.carousel-dot,
.pagination-dot,
[class*="indicator"],
.hero [class*="rounded-full"][style*="background"],
.hero .w-2.h-2,
.hero .w-3.h-3 {{
  background-color: var(--primary, {primary}) !important;
  border-color: var(--primary, {primary}) !important;
}}

/* Marquee border effect for hero */
.hero.marquee-style {{
  position: relative;
}}

.hero.marquee-style::before {{
  content: "";
  position: absolute;
  inset: -6px;
  border-radius: calc(var(--radius) + 8px);
  padding: 6px;
  background: conic-gradient(from 0deg, var(--primary, {primary}) 0 4deg, transparent 4deg 8deg) border-box;
  -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  animation: bulbs 6s linear infinite;
  opacity: 0.75;
  pointer-events: none;
}}

@keyframes bulbs {{
  to {{ transform: rotate(360deg); }}
}}
""")
    
    # Animations (if not already covered by motifs)
    if "twinkling-lights" in theme_spec.animations and "lights" not in motifs_str:
        css_parts.append("""
/* Twinkling Lights Animation */
.bulb {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: radial-gradient(circle at 40% 40%, #fff, var(--primary) 55%, var(--primary-700) 70%, #b66a00 100%);
  box-shadow: 0 0 12px rgba(255,193,7,.9);
  animation: twinkle 2s ease-in-out infinite;
}

.bulb:nth-child(odd) { animation-delay: 0.8s; }

@keyframes twinkle {
  50% { filter: brightness(1.6); }
}
""")
    
    # Responsive
    css_parts.append("""
/* Responsive Design */
@media (max-width: 1024px) {
  .hero-grid { grid-template-columns: 1fr; }
  .episode-card { grid-column: span 6; }
}

@media (max-width: 640px) {
  .container { padding: 18px; }
  .episode-card { grid-column: span 12; }
  .btn { padding: 12px 14px; }
}
""")
    
    return "\n".join(css_parts)


def generate_complete_theme(
    podcast: Podcast,
    cover_url: Optional[str] = None,
    tagline: Optional[str] = None,
    design_prefs: Optional[Dict[str, Any]] = None
) -> ThemeAnalysisResult:
    """
    Complete theme generation workflow.
    
    Analyzes podcast, generates theme spec, maps to sections, and generates CSS.
    """
    # Step 1: Analyze podcast
    theme_spec = analyze_podcast_for_theme(podcast, cover_url, tagline, design_prefs)
    theme_spec = _enforce_palette_contrast(theme_spec)
    
    # Step 2: Map to sections
    section_configs = map_theme_to_sections(theme_spec, podcast)
    
    # Step 3: Generate CSS
    css = generate_theme_css(theme_spec, section_configs)
    
    # Step 4: Create detailed description
    motifs_text = ', '.join(theme_spec.visual_motifs) if theme_spec.visual_motifs else 'modern design elements'
    animations_text = ', '.join(theme_spec.animations) if theme_spec.animations else 'smooth transitions'
    description = f"Generated a {theme_spec.mood} theme with {motifs_text}. Includes {animations_text} and a {theme_spec.component_styles.get('hero', 'standard')} hero style."
    
    # Store theme description in sections_config so it can be viewed/edited later
    section_configs["sections_config"]["_theme_metadata"] = {
        "description": description,
        "mood": theme_spec.mood,
        "visual_motifs": theme_spec.visual_motifs,
        "animations": theme_spec.animations,
        "component_styles": theme_spec.component_styles,
        "generated_at": datetime.utcnow().isoformat() if hasattr(datetime, 'utcnow') else None
    }
    
    # Also store the user preferences that were used
    if design_prefs:
        section_configs["sections_config"]["_theme_metadata"]["user_design_prefs"] = design_prefs
    
    return ThemeAnalysisResult(
        theme_spec=theme_spec,
        sections_config=section_configs,
        css=css,
        description=description
    )

