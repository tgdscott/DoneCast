"""
AI Theme Generator Service

Analyzes podcasts and generates custom themed designs that can be applied
to the block-based website builder.
"""

import json
import logging
from datetime import datetime
from typing import Any, Dict, List, Optional
from pydantic import BaseModel, Field

from api.models.podcast import Podcast
from api.services.ai_content import client_router as ai_client

log = logging.getLogger(__name__)


class ThemeSpec(BaseModel):
    """Theme specification generated by AI analysis."""
    mood: str = Field(..., description="Overall vibe (e.g., 'playful-cinematic', 'professional', 'cozy')")
    color_palette: Dict[str, str] = Field(..., description="CSS color variables")
    typography: Dict[str, str] = Field(..., description="Font choices and styles")
    visual_motifs: List[str] = Field(default_factory=list, description="Design elements to incorporate")
    animations: List[str] = Field(default_factory=list, description="Animation types to include")
    component_styles: Dict[str, str] = Field(default_factory=dict, description="Section-specific style variants")
    effects: List[str] = Field(default_factory=list, description="Visual effects to apply")


class ThemeAnalysisResult(BaseModel):
    """Complete theme analysis result."""
    theme_spec: ThemeSpec
    sections_config: Dict[str, Any]
    css: str
    description: str = Field(..., description="Human-readable description of the generated theme")


def analyze_podcast_for_theme(
    podcast: Podcast,
    cover_url: Optional[str] = None,
    tagline: Optional[str] = None
) -> ThemeSpec:
    """
    Analyze podcast metadata and cover art to generate a theme specification.
    
    Args:
        podcast: The podcast to analyze
        cover_url: URL to podcast cover art (optional)
        tagline: Podcast tagline if available
        
    Returns:
        ThemeSpec with colors, typography, motifs, animations, etc.
    """
    # Build analysis prompt
    description = podcast.description or "A podcast"
    cover_description = "vibrant and colorful" if cover_url else "not provided"
    
    prompt = f"""You are a web design expert analyzing a podcast for theme generation.

Podcast Title: {podcast.name}
Description: {description}
Tagline: {tagline or 'Not provided'}
Cover Art: {cover_description}

Analyze this podcast and generate a design theme specification in JSON format. Consider:
- The podcast's tone, genre, and target audience
- Visual elements that would match the content
- Color palettes that evoke the right mood
- Typography that fits the style
- Interactive elements and animations that enhance the experience

Output a JSON object with this exact structure:
{{
  "mood": "descriptive-mood-string",
  "color_palette": {{
    "bg": "#hexcolor",
    "bg_elev": "#hexcolor",
    "text": "#hexcolor",
    "muted": "#hexcolor",
    "primary": "#hexcolor",
    "primary_700": "#hexcolor",
    "accent": "#hexcolor",
    "danger": "#hexcolor"
  }},
  "typography": {{
    "heading_font": "Font Name, fallback, sans-serif",
    "body_font": "Font Name, fallback, sans-serif",
    "heading_style": "uppercase/bold/normal, letter-spacing value"
  }},
  "visual_motifs": ["motif1", "motif2"],
  "animations": ["animation1", "animation2"],
  "component_styles": {{
    "hero": "variant-name",
    "buttons": "variant-name",
    "episode_cards": "variant-name",
    "audio_player": "variant-name"
  }},
  "effects": ["effect1", "effect2"]
}}

Be creative but practical. The design should be:
- Visually distinctive and memorable
- Accessible (good contrast ratios)
- Responsive-friendly
- Aligned with the podcast's content and tone

Output ONLY valid JSON, no explanations or markdown fences."""

    try:
        response = ai_client.generate(prompt, max_output_tokens=2048, temperature=0.8)
        
        # Clean up response
        response = response.strip()
        if response.startswith("```json"):
            response = response[7:]
        elif response.startswith("```"):
            response = response[3:]
        if response.endswith("```"):
            response = response[:-3]
        response = response.strip()
        
        # Parse JSON
        theme_data = json.loads(response)
        
        # Validate and create ThemeSpec
        return ThemeSpec(**theme_data)
        
    except json.JSONDecodeError as e:
        log.error("Failed to parse theme JSON from AI: %s", e)
        if 'response' in locals():
            log.debug("AI response was: %s", response[:500] if len(response) > 500 else response)
        # Return a default theme as fallback
        return _get_default_theme_spec(podcast.name)
    except Exception as e:
        log.exception("Failed to generate theme spec: %s", e)
        return _get_default_theme_spec(podcast.name)


def _get_default_theme_spec(podcast_name: str) -> ThemeSpec:
    """Return a default theme spec as fallback."""
    return ThemeSpec(
        mood="professional-modern",
        color_palette={
            "bg": "#0f172a",
            "bg_elev": "#1e293b",
            "text": "#f8fafc",
            "muted": "#94a3b8",
            "primary": "#3b82f6",
            "primary_700": "#2563eb",
            "accent": "#8b5cf6",
            "danger": "#ef4444"
        },
        typography={
            "heading_font": "Inter, system-ui, sans-serif",
            "body_font": "Inter, system-ui, sans-serif",
            "heading_style": "bold, normal"
        },
        visual_motifs=["modern-minimal"],
        animations=["smooth-transitions"],
        component_styles={
            "hero": "standard",
            "buttons": "standard",
            "episode_cards": "standard",
            "audio_player": "standard"
        },
        effects=["subtle-shadows"]
    )


def map_theme_to_sections(theme_spec: ThemeSpec, podcast: Podcast) -> Dict[str, Any]:
    """
    Map theme specification to section configurations.
    
    Returns:
        {
            "sections_order": [...],
            "sections_config": {...},
            "section_styles": {...}
        }
    """
    # Determine section order based on theme
    sections_order = ["hero", "latest-episodes", "subscribe", "footer"]
    
    # Map component styles to section variants
    # Use CSS variables instead of hardcoded colors so theme CSS can control them
    sections_config = {
        "hero": {
            "variant": theme_spec.component_styles.get("hero", "standard"),
            "title": podcast.name,
            "subtitle": podcast.description or f"Welcome to {podcast.name}",
            "show_cover_art": True,  # Always show cover art in hero
            "background_style": "gradient" if "gradient" in theme_spec.effects else "solid",
            # Use CSS variables - theme CSS will provide the actual colors
            # These will be overridden by CSS !important rules
            "background_color": "var(--bg)",
            "text_color": "var(--text)"
        },
        "latest-episodes": {
            "variant": theme_spec.component_styles.get("episode_cards", "standard"),
            "count": 6,
            "layout": "grid",
            "show_descriptions": True,
            "show_dates": True
        },
        "subscribe": {
            "heading": "Subscribe & Listen",
            "layout": "icons"
        },
        "footer": {
            "show_social_links": True,
            "show_subscribe_links": True
        }
    }
    
    # Generate section-specific CSS classes
    section_styles = {}
    if theme_spec.component_styles.get("hero") != "standard":
        section_styles["hero"] = f".hero.{theme_spec.component_styles['hero']}"
    if theme_spec.component_styles.get("episode_cards") != "standard":
        section_styles["episodes"] = f".episode-card.{theme_spec.component_styles['episode_cards']}"
    
    return {
        "sections_order": sections_order,
        "sections_config": sections_config,
        "section_styles": section_styles
    }


def generate_theme_css(theme_spec: ThemeSpec, section_configs: Dict[str, Any]) -> str:
    """
    Generate complete CSS that styles building blocks to match the theme.
    
    This CSS will:
    1. Define CSS variables from color palette
    2. Add typography rules
    3. Style section variants
    4. Include animations
    5. Add component-specific styles
    """
    colors = theme_spec.color_palette
    typo = theme_spec.typography
    
    # Build CSS
    css_parts = []
    
    # CSS Variables - use f-string to avoid format() issues with CSS curly braces
    bg = colors.get("bg", "#0f172a")
    bg_elev = colors.get("bg_elev", "#1e293b")
    text = colors.get("text", "#f8fafc")
    muted = colors.get("muted", "#94a3b8")
    primary = colors.get("primary", "#3b82f6")
    primary_700 = colors.get("primary_700", "#2563eb")
    accent = colors.get("accent", "#8b5cf6")
    danger = colors.get("danger", "#ef4444")
    heading_font = typo.get("heading_font", "Inter, sans-serif")
    body_font = typo.get("body_font", "Inter, sans-serif")
    
    css_parts.append(f"""/* AI-Generated Theme CSS */
:root {{
  /* Color Palette */
  --bg: {bg};
  --bg-elev: {bg_elev};
  --text: {text};
  --muted: {muted};
  --primary: {primary};
  --primary-700: {primary_700};
  --accent: {accent};
  --danger: {danger};
  
  /* Typography */
  --font-heading: {heading_font};
  --font-body: {body_font};
  
  /* Spacing */
  --radius: 14px;
  --shadow: 0 10px 30px rgba(0,0,0,.35);
}}
""")
    
    # Base Styles - Apply theme to entire page
    css_parts.append(f"""
* {{ box-sizing: border-box; }}
html, body {{ height: 100%; }}
body {{
  margin: 0;
  background: var(--bg, {bg}) !important;
  color: var(--text, {text}) !important;
  font-family: var(--font-body, {body_font});
  line-height: 1.6;
}}

/* Apply theme colors to hero sections - use high specificity to override inline styles */
.hero,
div.hero,
.w-full.hero,
div.w-full.hero {{
  background: var(--bg, {bg}) !important;
  color: var(--text, {text}) !important;
}}

/* Force override inline background colors */
div[class*="hero"][style] {{
  background: var(--bg, {bg}) !important;
  color: var(--text, {text}) !important;
}}

/* Apply theme to episode cards */
.episode-card {{
  background: var(--bg-elev, {bg_elev}) !important;
  border-color: rgba(255, 255, 255, 0.1) !important;
  color: var(--text, {text}) !important;
}}

.container {{ max-width: 1100px; margin: 0 auto; padding: 24px; }}
""")
    
    # Hero Section Variants
    hero_variant = section_configs.get("sections_config", {}).get("hero", {}).get("variant", "standard")
    
    # Always add base hero styling
    css_parts.append(f"""
/* Base Hero Styling */
.hero {{
  background: var(--bg, {bg}) !important;
  color: var(--text, {text}) !important;
  position: relative;
}}
""")
    
    if hero_variant == "marquee-style":
        css_parts.append("""
/* Marquee Hero Style */
.hero.marquee-style {
  position: relative;
  padding: 24px;
  border-radius: var(--radius);
  background: linear-gradient(180deg, var(--bg-elev) 0%, var(--bg) 100%);
  box-shadow: var(--shadow);
  overflow: hidden;
}

.hero.marquee-style::before,
.hero.marquee-style::after {
  content: "";
  position: absolute;
  inset: -6px;
  border-radius: calc(var(--radius) + 8px);
  padding: 6px;
  background: conic-gradient(from 0deg, var(--primary) 0 4deg, transparent 4deg 8deg) border-box;
  -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  animation: bulbs 6s linear infinite;
  opacity: 0.75;
}

.hero.marquee-style::after {
  filter: blur(8px);
  opacity: 0.35;
}

@keyframes bulbs {
  to { transform: rotate(360deg); }
}
""")
    
    # Episode Card Variants
    episode_variant = section_configs.get("sections_config", {}).get("latest-episodes", {}).get("variant", "standard")
    if episode_variant == "movie-poster-style":
        css_parts.append("""
/* Movie Poster Episode Cards */
.episode-card.movie-poster-style {
  background: linear-gradient(180deg, var(--bg-elev) 0%, var(--bg) 100%);
  border: 1px solid rgba(255,255,255,.06);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  overflow: hidden;
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}

.episode-card.movie-poster-style:hover {
  transform: translateY(-2px);
  box-shadow: 0 18px 40px rgba(0,0,0,.45);
}

.episode-card.movie-poster-style .poster {
  height: 170px;
  background: linear-gradient(180deg, rgba(183,28,28,.25), rgba(183,28,28,0));
  border-bottom: 1px solid rgba(255,255,255,.06);
}
""")
    
    # Button Variants
    button_variant = theme_spec.component_styles.get("buttons", "standard")
    if button_variant == "ticket-style":
        css_parts.append("""
/* Ticket-Style Buttons */
.btn.ticket-style {
  position: relative;
  display: inline-flex;
  align-items: center;
  gap: 10px;
  padding: 14px 18px;
  font-weight: 700;
  letter-spacing: 0.4px;
  text-transform: uppercase;
  background: linear-gradient(180deg, var(--primary) 0%, var(--primary-700) 100%);
  color: #1a1200;
  border: none;
  cursor: pointer;
  border-radius: 12px;
  box-shadow: 0 6px 0 rgba(0,0,0,.25), var(--shadow);
  transition: transform 0.12s ease, filter 0.12s ease;
  clip-path: polygon(8px 0, calc(100% - 8px) 0, 100% 8px, 100% calc(100% - 8px), calc(100% - 8px) 100%, 8px 100%, 0 calc(100% - 8px), 0 8px);
}

.btn.ticket-style::before,
.btn.ticket-style::after {
  content: "";
  position: absolute;
  top: 0;
  bottom: 0;
  width: 10px;
  background: radial-gradient(circle at 50% 6px, rgba(0,0,0,.45) 2px, transparent 2px) repeat-y;
  background-size: 10px 14px;
  opacity: 0.6;
}

.btn.ticket-style::before { left: -6px; }
.btn.ticket-style::after { right: -6px; transform: scaleX(-1); }

.btn.ticket-style:hover {
  transform: translateY(-1px);
  filter: saturate(1.1);
}

.btn.ticket-style:active {
  transform: translateY(1px);
}
""")
    
    # Typography
    heading_style = typo.get("heading_style", "bold, normal")
    if "uppercase" in heading_style:
        css_parts.append("""
h1, h2, h3 {
  font-family: var(--font-heading);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--primary);
  text-shadow: 0 2px 0 rgba(0,0,0,.5), 0 0 24px rgba(255,193,7,.35);
}
""")
    
    # Visual Motifs - actually implement them!
    motifs_str = ' '.join(theme_spec.visual_motifs).lower()
    
    # Popcorn kernels motif
    if "popcorn" in motifs_str or ("cinema" in motifs_str and "theater" in motifs_str):
        css_parts.append("""
/* Popcorn Decorative Elements */
.popcorn-decoration::before {
  content: "ðŸ¿";
  font-size: 1.2em;
  margin-right: 0.5em;
  opacity: 0.8;
}

.episode-card::after {
  content: "";
  position: absolute;
  top: -10px;
  right: 10px;
  width: 20px;
  height: 20px;
  background: radial-gradient(circle, var(--primary) 0%, transparent 70%);
  border-radius: 50%;
  opacity: 0.3;
  pointer-events: none;
}
""")
    
    # Theater bulbs / Marquee lights
    if "marquee" in motifs_str or "lights" in motifs_str or "theater" in motifs_str or "bulb" in motifs_str:
        css_parts.append("""
/* Theater Bulbs / Marquee Lights */
.bulb-row {
  display: flex !important;
  justify-content: center;
  gap: 8px;
  padding: 12px 0 26px;
  opacity: 0.85;
  z-index: 10;
  pointer-events: none;
}

.bulb {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: radial-gradient(circle at 40% 40%, #fff, var(--primary) 55%, var(--primary-700) 70%, #b66a00 100%);
  box-shadow: 0 0 12px rgba(255,193,7,.9);
  animation: twinkle 2s ease-in-out infinite;
}

.bulb:nth-child(odd) { animation-delay: 0.8s; }
.bulb:nth-child(even) { animation-delay: 0.4s; }

@keyframes twinkle {
  0%, 100% { filter: brightness(1); opacity: 0.85; }
  50% { filter: brightness(1.6); opacity: 1; }
}

/* Marquee border effect for hero */
.hero.marquee-style {
  position: relative;
}

.hero.marquee-style::before {
  content: "";
  position: absolute;
  inset: -6px;
  border-radius: calc(var(--radius) + 8px);
  padding: 6px;
  background: conic-gradient(from 0deg, var(--primary) 0 4deg, transparent 4deg 8deg) border-box;
  -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  animation: bulbs 6s linear infinite;
  opacity: 0.75;
  pointer-events: none;
}

@keyframes bulbs {
  to { transform: rotate(360deg); }
}
""")
    
    # Animations (if not already covered by motifs)
    if "twinkling-lights" in theme_spec.animations and "lights" not in motifs_str:
        css_parts.append("""
/* Twinkling Lights Animation */
.bulb {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: radial-gradient(circle at 40% 40%, #fff, var(--primary) 55%, var(--primary-700) 70%, #b66a00 100%);
  box-shadow: 0 0 12px rgba(255,193,7,.9);
  animation: twinkle 2s ease-in-out infinite;
}

.bulb:nth-child(odd) { animation-delay: 0.8s; }

@keyframes twinkle {
  50% { filter: brightness(1.6); }
}
""")
    
    # Responsive
    css_parts.append("""
/* Responsive Design */
@media (max-width: 1024px) {
  .hero-grid { grid-template-columns: 1fr; }
  .episode-card { grid-column: span 6; }
}

@media (max-width: 640px) {
  .container { padding: 18px; }
  .episode-card { grid-column: span 12; }
  .btn { padding: 12px 14px; }
}
""")
    
    return "\n".join(css_parts)


def generate_complete_theme(
    podcast: Podcast,
    cover_url: Optional[str] = None,
    tagline: Optional[str] = None
) -> ThemeAnalysisResult:
    """
    Complete theme generation workflow.
    
    Analyzes podcast, generates theme spec, maps to sections, and generates CSS.
    """
    # Step 1: Analyze podcast
    theme_spec = analyze_podcast_for_theme(podcast, cover_url, tagline)
    
    # Step 2: Map to sections
    section_configs = map_theme_to_sections(theme_spec, podcast)
    
    # Step 3: Generate CSS
    css = generate_theme_css(theme_spec, section_configs)
    
    # Step 4: Create detailed description
    motifs_text = ', '.join(theme_spec.visual_motifs) if theme_spec.visual_motifs else 'modern design elements'
    animations_text = ', '.join(theme_spec.animations) if theme_spec.animations else 'smooth transitions'
    description = f"Generated a {theme_spec.mood} theme with {motifs_text}. Includes {animations_text} and a {theme_spec.component_styles.get('hero', 'standard')} hero style."
    
    # Store theme description in sections_config so it can be viewed/edited later
    section_configs["sections_config"]["_theme_metadata"] = {
        "description": description,
        "mood": theme_spec.mood,
        "visual_motifs": theme_spec.visual_motifs,
        "animations": theme_spec.animations,
        "component_styles": theme_spec.component_styles,
        "generated_at": datetime.utcnow().isoformat() if hasattr(datetime, 'utcnow') else None
    }
    
    return ThemeAnalysisResult(
        theme_spec=theme_spec,
        sections_config=section_configs,
        css=css,
        description=description
    )

